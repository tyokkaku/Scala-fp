# 11.パーサーコンビネーター

## パーサーコンビネーター

パーサー： 入力言語をソフトウェアが処理できるデータ構造に変換する構文解析器
パーサーコンビネーター： 関数であるパーサーの様々な合成法法を提供するライブラリ


## 関数としてのパーサー
## 抽象化したパーサーの実装
## 関数の合成で作るパーサー

- 合成
  - 選択
  - 逐次合成
  - 繰り返し
  - 区切りのついた繰り返し

## コンビネーターをライブラリ化する
## BNF

BNF(バッカスナウア)記法

```
例
<expr> ::= <term>|<expr><addop><term>

ルール： <expr> が <term> または <expr><addop><term> という形式で書かれる

""    ：文字列は "" で囲む
{}    ：0回以上の繰り返し
*     ：*を後ろにつけたときも、0回以上の繰り返し
+     ：1回以上の繰り返し
[]    ：[]で囲んだ部分は省略可能
()    ：()で囲んだ部分をグループ化する
```

## 郵便番号パーサーに必要なコンビネーターの追加

逐次合成 ： 2つから1つずつ適用し、最終的に両方成功したら、両方の結果をまとめて返す。片方が失敗したら、Failureを返す。

## 郵便番号パーサーの実装


## 課題

### 初級

```scala
package jp.ed.nnn.parsercombinator

case class FullClassName(garede: String, className: String)

// <grade> ::= "1" | "2" | "3"
// <class-name> ::= "A" | "B" | "C" | "D"
// <full-class-name> ::=  <grade> "年" <class-name> "組"

object FullClassNameParser extends MyFirstCombinator {

  def grade: Parser[String] = oneOf('1' to '3')

  def className: Parser[String] = oneOf('A' to 'D')

  def gradeCode: Parser[String] = map(grade, { t: String => t })

  def classNameCode: Parser[String] = map(className, { t: String => t })

  def apply(input: String): ParseResult[FullClassName] =
    map(combine(combine(combine(grade, s("年")), className), s("組")), {
      t: (((String, String), String), String) => FullClassName(t._1._1._1, t._1._2)
    })(input)
}
```